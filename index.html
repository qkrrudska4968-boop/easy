<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>SimpleCAD Web Tool v8 (ì¤Œ ê¸°ëŠ¥ ì¶”ê°€)</title>
    <style>
        #drawingCanvas {
            border: 2px solid #ccc;
            background-color: #f4f4f4;
            cursor: crosshair;
        }
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        button {
            padding: 5px 10px;
            margin: 3px;
            font-size: 14px;
            cursor: pointer;
        }
        .mode-active {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
        }
        .mode-arc {
            background-color: #2196F3;
            color: white;
        }
        #coordDisplay {
            margin-top: 10px;
            padding: 5px;
            border: 1px solid #aaa;
            background-color: #e0e0e0;
            font-weight: bold;
        }
        .control-group {
            margin: 15px 0;
            padding: 10px;
            border: 1px dashed #ccc;
            display: inline-block;
        }
    </style>
</head>
<body>
    <h2>SimpleCAD Drawing Tool v8 (ì¤Œ ê¸°ëŠ¥ ì¶”ê°€)</h2>
    
    <button onclick="clearCanvas()">ëª¨ë‘ ì§€ìš°ê¸°</button>
    <button onclick="undoLastLine()">ì‹¤í–‰ ì·¨ì†Œ (Undo)</button> 
    <button onclick="changeColor('red')">ë¹¨ê°„ ì„ </button>
    <button onclick="changeColor('blue')">íŒŒë€ ì„ </button>
    <br>
    <button id="zoomInBtn" onclick="applyZoom(1.1)">ğŸ” ì¤Œì¸ (+)</button>
    <button id="zoomOutBtn" onclick="applyZoom(0.9)">ğŸ” ì¤Œì•„ì›ƒ (-)</button>
    <br><br>
    
    <button id="lineModeBtn" onclick="toggleLineMode()" class="mode-active">ë¼ì¸ ê·¸ë¦¬ê¸° (ON)</button>
    <button id="arcModeBtn" onclick="toggleArcMode()">ì›í˜¸ ê·¸ë¦¬ê¸° (OFF)</button>

    <div class="control-group">
        <p>ë²„íŠ¼ìœ¼ë¡œ ì¹˜ìˆ˜ ì…ë ¥ í›„ ê·¸ë¦¬ê¸°:</p>
        <button onclick="drawDimensionedLine('right')">â†’ ì˜¤ë¥¸ìª½</button>
        <button onclick="drawDimensionedLine('left')">â† ì™¼ìª½</button>
        <button onclick="drawDimensionedLine('up')">â†‘ ìœ„ìª½</button>
        <button onclick="drawDimensionedLine('down')">â†“ ì•„ë˜ìª½</button>
    </div>
    
    <canvas id="drawingCanvas" width="800" height="600"></canvas>
    
    <div id="coordDisplay">
        í˜„ì¬ ì¢Œí‘œ: X = 400, Y = 300 | ìŠ¤ì¼€ì¼: 1.0
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const coordDisplay = document.getElementById('coordDisplay');
        const lineModeBtn = document.getElementById('lineModeBtn');
        const arcModeBtn = document.getElementById('arcModeBtn');

        let isLineMode = true;
        let isArcMode = false;
        
        let drawnLines = []; 
        let isDrawing = false; 
        let currentLineColor = 'blue'; 
        
        // ì¤Œ ë° ì¢Œí‘œê³„ ë³€ìˆ˜ ì¶”ê°€
        let scale = 1.0; 
        let lastX = canvas.width / 2;
        let lastY = canvas.height / 2; 
        let startX = 0;
        let startY = 0;
        
        let arcPoints = [];

        updateCoordDisplay();

        // --- ì¤Œ ì»¨íŠ¸ë¡¤ í•¨ìˆ˜ ---
        function applyZoom(factor) {
            scale *= factor;
            // ìµœì†Œ/ìµœëŒ€ ì¤Œ ì œí•œ (ì˜ˆ: 0.2ë°° ~ 5ë°°)
            scale = Math.max(0.2, Math.min(5.0, scale));
            redrawAll();
            updateCoordDisplay();
        }
        
        // --- ìº”ë²„ìŠ¤ ì¢Œí‘œë¥¼ ì‹¤ì œ ë„ë©´ ì¢Œí‘œë¡œ ë³€í™˜ ---
        function getRealCoords(canvasX, canvasY) {
            return {
                x: canvasX / scale,
                y: canvasY / scale
            };
        }
        
        // --- ì‹¤ì œ ë„ë©´ ì¢Œí‘œë¥¼ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜ ---
        function getCanvasCoords(realX, realY) {
            return {
                x: realX * scale,
                y: realY * scale
            };
        }

        // --- ëª¨ë“œ í† ê¸€ í•¨ìˆ˜ ---
        function toggleLineMode() {
            if (isArcMode) toggleArcMode();
            isLineMode = true;
            lineModeBtn.classList.add('mode-active');
            lineModeBtn.textContent = "ë¼ì¸ ê·¸ë¦¬ê¸° (ON)";
            arcPoints = [];
        }

        function toggleArcMode() {
            if (isLineMode) {
                isLineMode = false;
                lineModeBtn.classList.remove('mode-active');
                lineModeBtn.textContent = "ë¼ì¸ ê·¸ë¦¬ê¸° (OFF)";
            }
            isArcMode = !isArcMode;
            if (isArcMode) {
                arcModeBtn.classList.add('mode-arc');
                arcModeBtn.textContent = "ì›í˜¸ ê·¸ë¦¬ê¸° (ON) - 3ì  í´ë¦­";
            } else {
                arcModeBtn.classList.remove('mode-arc');
                arcModeBtn.textContent = "ì›í˜¸ ê·¸ë¦¬ê¸° (OFF)";
                arcPoints = [];
            }
            updateCoordDisplay();
        }
        
        // --- ìœ í‹¸ë¦¬í‹°: ì¢Œí‘œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ---
        function updateCoordDisplay() {
            coordDisplay.textContent = `í˜„ì¬ ì¢Œí‘œ: X = ${Math.round(lastX)}, Y = ${Math.round(lastY)} | ìŠ¤ì¼€ì¼: ${scale.toFixed(2)}`;
            if (isArcMode && arcPoints.length > 0) {
                 coordDisplay.textContent += ` | ì›í˜¸ í´ë¦­ (${arcPoints.length} / 3)`;
            }
        }

        // --- í•µì‹¬: ëª¨ë“  ì„  ë‹¤ì‹œ ê·¸ë¦¬ê¸° ---
        function redrawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawnLines.forEach(item => {
                if (item.type === 'line') {
                    const p1 = getCanvasCoords(item.x1, item.y1);
                    const p2 = getCanvasCoords(item.x2, item.y2);
                    drawSingleLine(p1.x, p1.y, p2.x, p2.y, item.color);
                    drawDimension(p1.x, p1.y, p2.x, p2.y);
                } else if (item.type === 'arc') {
                    const p1 = getCanvasCoords(item.p1.x, item.p1.y);
                    const p2 = getCanvasCoords(item.p2.x, item.p2.y);
                    const p3 = getCanvasCoords(item.p3.x, item.p3.y);
                    drawSingleArc({x: p1.x, y: p1.y}, {x: p2.x, y: p2.y}, {x: p3.x, y: p3.y}, item.color, item.realRadius);
                }
            });
        }
        
        function drawSingleLine(x1, y1, x2, y2, color) {
             ctx.strokeStyle = color;
             ctx.lineWidth = 2;
             ctx.beginPath();
             ctx.moveTo(x1, y1);
             ctx.lineTo(x2, y2);
             ctx.stroke();
        }
        
        function drawLineAndSave(x1, y1, x2, y2, color) {
            // ì €ì¥í•  ë•ŒëŠ” ì‹¤ì œ ë„ë©´ ì¢Œí‘œ(ì¤Œ ì ìš© ì•ˆ ëœ)ë¡œ ì €ì¥
            drawnLines.push({type: 'line', x1, y1, x2, y2, color});

            // í™”ë©´ì— ê·¸ë¦´ ë•ŒëŠ” ìº”ë²„ìŠ¤ ì¢Œí‘œ(ì¤Œ ì ìš©ëœ)ë¡œ ë³€í™˜
            const cp1 = getCanvasCoords(x1, y1);
            const cp2 = getCanvasCoords(x2, y2);
            drawSingleLine(cp1.x, cp1.y, cp2.x, cp2.y, color);
            drawDimension(cp1.x, cp1.y, cp2.x, cp2.y);
        }

        function drawDimension(x1, y1, x2, y2) {
            // ì¹˜ìˆ˜ëŠ” ì‹¤ì œ ê¸¸ì´(ì¤Œ ì ìš© ì•ˆ ëœ ê¸¸ì´)ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
            const length = Math.round(Math.sqrt(Math.pow((x2 - x1)/scale, 2) + Math.pow((y2 - y1)/scale, 2)));
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            
            ctx.fillStyle = "black";
            ctx.font = `${12 / scale}px Arial`; // í°íŠ¸ í¬ê¸°ë„ ì¤Œì— ë”°ë¼ ì¡°ì •
            ctx.textAlign = "center";
            ctx.fillText(`${length} px`, midX, midY - (5 / scale));
        }

        // --- ì›í˜¸(Arc) ê·¸ë¦¬ê¸° ì „ìš© í•¨ìˆ˜ ---
        function getArcCenterAndRadius(p1, p2, p3) {
             // ì¢Œí‘œ ê³„ì‚°ì€ ìº”ë²„ìŠ¤ ì¢Œí‘œê°€ ì•„ë‹Œ ì‹¤ì œ ë„ë©´ ì¢Œí‘œë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;

            const D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));
            if (Math.abs(D) < 1e-6) return null;

            const cx = ((x1 * x1 + y1 * y1) * (y2 - y3) + (x2 * x2 + y2 * y2) * (y3 - y1) + (x3 * x3 + y3 * y3) * (y1 - y2)) / D;
            const cy = ((x1 * x1 + y1 * y1) * (x3 - x2) + (x2 * x2 + y2 * y2) * (x1 - x3) + (x3 * x3 + y3 * y3) * (x2 - x1)) / D;
            const radius = Math.sqrt((x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy));

            return { cx, cy, radius };
        }

        function drawSingleArc(p1, p2, p3, color, realRadius) {
            // ì´ í•¨ìˆ˜ëŠ” ì´ë¯¸ ìº”ë²„ìŠ¤ ì¢Œí‘œë¥¼ ë°›ì•„ ë Œë”ë§ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤. (redrawAllì—ì„œ í˜¸ì¶œë¨)
            const arcData = getArcCenterAndRadius(p1, p2, p3);
            if (!arcData) return;

            // cx, cy, radiusëŠ” ì´ë¯¸ ìº”ë²„ìŠ¤ ìŠ¤ì¼€ì¼ì´ ì ìš©ëœ ì¢Œí‘œì…ë‹ˆë‹¤.
            const { cx, cy, radius } = arcData; 
            let startAngle = Math.atan2(p1.y - cy, p1.x - cx);
            let endAngle = Math.atan2(p3.y - cy, p3.x - cx);
            let counterClockwise = false; 

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            ctx.arc(cx, cy, radius, startAngle, endAngle, counterClockwise); 
            ctx.stroke();

            const chordLength = Math.sqrt(Math.pow(p3.x - p1.x, 2) + Math.pow(p3.y - p1.y, 2)) / scale;
            
            ctx.fillStyle = "black";
            ctx.font = `${12 / scale}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(`Radius: ${Math.round(realRadius)} px, Chord: ${Math.round(chordLength)} px`, cx, cy + (radius / 2) * Math.sin(startAngle) + (radius / 2) * Math.sin(endAngle));
        }
        
        function drawArcAndSave(p1, p2, p3, color) {
            const realArcData = getArcCenterAndRadius(p1, p2, p3);
            if (!realArcData) return;

            const { radius } = realArcData;
            
            drawnLines.push({type: 'arc', p1: p1, p2: p2, p3: p3, color: color, realRadius: radius});
        }


        // --- ë°©í–¥ ì„ íƒ ì¹˜ìˆ˜ì„  ê°•ì œ ê·¸ë¦¬ê¸° í•¨ìˆ˜ ---
        function drawDimensionedLine(direction) {
            const lengthStr = prompt(`ì„  ê¸¸ì´(px)ë¥¼ ì…ë ¥í•˜ì„¸ìš”.`, 100);
            const length = parseInt(lengthStr);

            if (isNaN(length) || length < 10) return;
            
            let endX = lastX; 
            let endY = lastY; 
            
            switch (direction) {
                case 'right': endX = lastX + length; break;
                case 'left': endX = lastX - length; break;
                case 'up': endY = lastY - length; break;
                case 'down': endY = lastY + length; break;
                default: return;
            }
            
            drawLineAndSave(lastX, lastY, endX, endY, currentLineColor);
            lastX = endX;
            lastY = endY;
            redrawAll(); // ì¤Œì´ ì ìš©ë˜ë„ë¡ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
            updateCoordDisplay();
        }
        
        // --- ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---
        canvas.addEventListener('mousedown', (e) => {
            const realClick = getRealCoords(e.offsetX, e.offsetY);
            const clickX = realClick.x;
            const clickY = realClick.y;

            // 1. ì›í˜¸ ëª¨ë“œ (Arc Mode) ì²˜ë¦¬
            if (isArcMode) {
                arcPoints.push({x: clickX, y: clickY});
                
                if (arcPoints.length === 3) {
                    const p1 = arcPoints[0];
                    const p3 = arcPoints[2];
                    
                    drawArcAndSave(arcPoints[0], arcPoints[1], arcPoints[2], currentLineColor);
                    redrawAll();
                    arcPoints = [];
                    lastX = p3.x; // ì‹¤ì œ ì¢Œí‘œ ì €ì¥
                    lastY = p3.y;
                } else {
                    updateCoordDisplay();
                }
                return;
            }
            
            // 2. ë¼ì¸ ëª¨ë“œ (Line Mode) ì²˜ë¦¬
            if (isLineMode) {
                // ë§ˆìš°ìŠ¤ í´ë¦­ ì‹œì ì˜ ì‹¤ì œ ì¢Œí‘œë¥¼ ì €ì¥
                [startX, startY] = [clickX, clickY];
                isDrawing = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const realMove = getRealCoords(e.offsetX, e.offsetY);
            lastX = realMove.x; // ì‹¤ì œ ì¢Œí‘œ ì—…ë°ì´íŠ¸
            lastY = realMove.y;
            updateCoordDisplay();

            if (isLineMode && isDrawing) {
                redrawAll();
                // ìº”ë²„ìŠ¤ ì¢Œí‘œë¥¼ ì‚¬ìš©í•˜ì—¬ ì„ì‹œ ì„ ì„ ê·¸ë¦½ë‹ˆë‹¤.
                drawSingleLine(e.offsetX, e.offsetY, getCanvasCoords(startX, startY).x, getCanvasCoords(startX, startY).y, currentLineColor);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isLineMode || !isDrawing) return;
            isDrawing = false;
            
            const realUp = getRealCoords(e.offsetX, e.offsetY);
            let endX = realUp.x;
            let endY = realUp.y;
            
            drawLineAndSave(startX, startY, endX, endY, currentLineColor);
            
            lastX = endX;
            lastY = endY;
            redrawAll();
            updateCoordDisplay();
        });

        // --- ë”ë¸”í´ë¦­ ì¹˜ìˆ˜ ìˆ˜ì • (ë¼ì¸ì—ë§Œ ì ìš©) ---
        canvas.addEventListener('dblclick', handleDblClick);

        function handleDblClick(e) {
            const realClick = getRealCoords(e.offsetX, e.offsetY);
            const clickX = realClick.x; // ì‹¤ì œ ì¢Œí‘œ ì‚¬ìš©
            const clickY = realClick.y;
            
            const clickedLineIndex = drawnLines.findIndex(item => {
                if (item.type !== 'line') return false;
                const line = item;
                
                // ì‹¤ì œ ì¢Œí‘œë¥¼ ê¸°ì¤€ìœ¼ë¡œ í´ë¦­ ì˜ì—­ íŒë‹¨
                const minX = Math.min(line.x1, line.x2) - 5;
                const maxX = Math.max(line.x1, line.x2) + 5;
                const minY = Math.min(line.y1, line.y2) - 5;
                const maxY = Math.max(line.y1, line.y2) + 5;
                return clickX >= minX && clickX <= maxX && clickY >= minY && clickY <= maxY;
            });

            if (clickedLineIndex !== -1) {
                const line = drawnLines[clickedLineIndex];
                
                const currentLength = Math.round(Math.sqrt(Math.pow(line.x2 - line.x1, 2) + Math.pow(line.y2 - line.y1, 2)));
                const newLengthStr = prompt(`ìƒˆ ê¸¸ì´ë¥¼ ì…ë ¥í•˜ì„¸ìš” (í˜„ì¬ ê¸¸ì´: ${currentLength} px):`, currentLength);
                const newLength = parseInt(newLengthStr);

                if (!isNaN(newLength) && newLength > 0 && newLength !== currentLength) {
                    
                    const dx = line.x2 - line.x1;
                    const dy = line.y2 - line.y1;
                    const angle = Math.atan2(dy, dx); 

                    line.x2 = line.x1 + newLength * Math.cos(angle);
                    line.y2 = line.y1 + newLength * Math.sin(angle);
                    
                    if (clickedLineIndex === drawnLines.length - 1) {
                        lastX = line.x2;
                        lastY = line.y2;
                        updateCoordDisplay();
                    }
                    
                    redrawAll(); 
                }
            }
        }
        
        // --- ê¸°ëŠ¥: ì‹¤í–‰ ì·¨ì†Œ (Undo) ---
        function undoLastLine() {
            if (drawnLines.length > 0) {
                drawnLines.pop(); 
                redrawAll(); 
                
                if (drawnLines.length > 0) {
                    const lastDrawn = drawnLines[drawnLines.length - 1];
                    lastX = lastDrawn.type === 'line' ? lastDrawn.x2 : lastDrawn.p3.x;
                    lastY = lastDrawn.type === 'line' ? lastDrawn.y2 : lastDrawn.p3.y;
                } else {
                    lastX = canvas.width / 2;
                    lastY = canvas.height / 2;
                }
                arcPoints = [];
                updateCoordDisplay();
            }
        }
        
        // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawnLines = []; 
            arcPoints = [];
            scale = 1.0; // ì¤Œ ì´ˆê¸°í™”
            lastX = canvas.width / 2;
            lastY = canvas.height / 2; 
            updateCoordDisplay(); 
        }

        function changeColor(newColor) {
            currentLineColor = newColor;
        }
        
        canvas.addEventListener('mouseout', () => isDrawing = false);

    </script>
</body>
</html>